<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Living Programming Thinking">
<meta property="og:type" content="website">
<meta property="og:title" content="Yestermorrow">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Yestermorrow">
<meta property="og:description" content="Living Programming Thinking">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yestermorrow">
<meta name="twitter:description" content="Living Programming Thinking">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Yestermorrow</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yestermorrow</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/29/线程池ThreadPoolExecutor类源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wanyajing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yestermorrow">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/29/线程池ThreadPoolExecutor类源码解析/" itemprop="url">线程池ThreadPoolExecutor类源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-29T20:22:10+08:00">
                2018-01-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线程池ThreadPoolExecutor类源码解析"><a href="#线程池ThreadPoolExecutor类源码解析" class="headerlink" title="线程池ThreadPoolExecutor类源码解析"></a>线程池ThreadPoolExecutor类源码解析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Executors是java线程池的工厂类，通过它可以快速初始化一个符合业务需求的线程池</p>
<p><img src="/2018/01/29/线程池ThreadPoolExecutor类源码解析/thread.png" alt="thread1"></p>
<h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**ctl代表2个含义：高3位代表线程运行状态，低29位代表线程数*/</span><br><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); //11100000000000</span><br><span class="line">   private static final int COUNT_BITS = Integer.SIZE - 3; //29</span><br><span class="line">   private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1; //00011111111111111111111111</span><br><span class="line"></span><br><span class="line">   // runState is stored in the high-order bits</span><br><span class="line">   /**</span><br><span class="line">   *   RUNNING:  接收新的任务并且也会处理已经提交等待的任务</span><br><span class="line">*   SHUTDOWN: 不会接收新的任务，但会处理已经提交等待的任务</span><br><span class="line">	*   STOP:     不接受新任务，不处理已经提交等待的任务，而且还会中断处理中的任务</span><br><span class="line">	*   TIDYING:  所有的任务被终止，workCount为0，为此状态时将会调用terminated()方法</span><br><span class="line">	*   TERMINATED: terminated()调用完成</span><br><span class="line">*/</span><br><span class="line">   private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS; //11100000000000000000000000000000</span><br><span class="line">   private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS; //00000000000000000000000000000000</span><br><span class="line">   private static final int STOP       =  1 &lt;&lt; COUNT_BITS; //00100000000000000000000000000000</span><br><span class="line">   private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS; //01000000000000000000000000000000</span><br><span class="line">   private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS; //01100000000000000000000000000000</span><br><span class="line">   </span><br><span class="line">   // Packing and unpacking ctl</span><br><span class="line">   private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;//&amp;操作比较高3位获取线程</span><br><span class="line">   private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;// &amp;比较低29位获取线程数</span><br><span class="line">   private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;//通过rs高3位运行状态|wc低29位</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 一般来说，如果线程池大小没到corePoolSize大小，会新增线程运行，如果到了，就加入    workQueue这个阻塞队列</span><br><span class="line"> * /</span><br><span class="line">private final BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">/**</span><br><span class="line"> * 可重入锁，不同于AQS（不可重入锁，下文addWorker方法会介绍）</span><br><span class="line"> * /</span><br><span class="line">private final ReentrantLock mainLock = new ReentrantLock();</span><br><span class="line">/**</span><br><span class="line"> * 线程池，所有的线程</span><br><span class="line"> * /</span><br><span class="line">private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</span><br><span class="line">/**</span><br><span class="line"> * awaitTermination时条件</span><br><span class="line"> */</span><br><span class="line">private final Condition termination = mainLock.newCondition();</span><br><span class="line">/**</span><br><span class="line"> * 线程池线程最大数量</span><br><span class="line"> */</span><br><span class="line">private int largestPoolSize;</span><br><span class="line">/**</span><br><span class="line"> * 已经结束的任务，只有在关闭线程池的时候才累加</span><br><span class="line"> */</span><br><span class="line">private long completedTaskCount;</span><br><span class="line">/**</span><br><span class="line"> * 线程池工厂，里面有一个newThread()方法用来产生工作线程，如果构造没提供，默认有一个</span><br><span class="line"> */</span><br><span class="line">private volatile ThreadFactory threadFactory;</span><br><span class="line">/**</span><br><span class="line"> * 大部分用在线程池满了以后，新的任务过来，使用那种拒绝策略，默认会提供一个</span><br><span class="line"> */</span><br><span class="line">private volatile RejectedExecutionHandler handler;</span><br><span class="line">/** </span><br><span class="line"> * 线程数量大于corePoolSize时，线程可以空闲的时间，如果设置了allowCoreThreadTimeOut，小于corePoolSize时也一样处理，否则就等待任务到来</span><br><span class="line"> */</span><br><span class="line">private volatile long keepAliveTime;</span><br><span class="line">/**</span><br><span class="line"> * false，核心线程空闲等待，true的话就是用keepAliveTime超时控制获取任务</span><br><span class="line"> */</span><br><span class="line">private volatile boolean allowCoreThreadTimeOut;</span><br><span class="line">/**</span><br><span class="line"> * 核心线程数量</span><br><span class="line"> */</span><br><span class="line">private volatile int corePoolSize;</span><br><span class="line">/**</span><br><span class="line"> * 跟largestPoolSize这个不一样，这个用来控制线程池大小</span><br><span class="line"> */</span><br><span class="line">private volatile int maximumPoolSize;</span><br><span class="line">/**</span><br><span class="line"> * 默认的拒绝策略</span><br><span class="line"> */</span><br><span class="line">private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();</span><br></pre></td></tr></table></figure>
<h3 id="初始化ThredPoolExecutor"><a href="#初始化ThredPoolExecutor" class="headerlink" title="初始化ThredPoolExecutor"></a>初始化ThredPoolExecutor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial</span><br><span class="line">    * parameters.</span><br><span class="line">    *</span><br><span class="line">    * @param corePoolSize the number of threads to keep in the pool, even</span><br><span class="line">    *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set</span><br><span class="line">    * @param maximumPoolSize the maximum number of threads to allow in the</span><br><span class="line">    *        pool</span><br><span class="line">    * @param keepAliveTime when the number of threads is greater than</span><br><span class="line">    *        the core, this is the maximum time that excess idle threads</span><br><span class="line">    *        will wait for new tasks before terminating.</span><br><span class="line">    * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument</span><br><span class="line">    * @param workQueue the queue to use for holding tasks before they are</span><br><span class="line">    *        executed.  This queue will hold only the &#123;@code Runnable&#125;</span><br><span class="line">    *        tasks submitted by the &#123;@code execute&#125; method.</span><br><span class="line">    * @param threadFactory the factory to use when the executor</span><br><span class="line">    *        creates a new thread</span><br><span class="line">    * @param handler the handler to use when execution is blocked</span><br><span class="line">    *        because the thread bounds and queue capacities are reached</span><br><span class="line">    * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;</span><br><span class="line">    *         &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt;</span><br><span class="line">    *         &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt;</span><br><span class="line">    *         &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span><br><span class="line">    *         &#123;@code maximumPoolSize &lt; corePoolSize&#125;</span><br><span class="line">    * @throws NullPointerException if &#123;@code workQueue&#125;</span><br><span class="line">    *         or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null</span><br><span class="line">    */</span><br><span class="line">   public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                             int maximumPoolSize,</span><br><span class="line">                             long keepAliveTime,</span><br><span class="line">                             TimeUnit unit,</span><br><span class="line">                             BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                             ThreadFactory threadFactory,</span><br><span class="line">                             RejectedExecutionHandler handler) &#123;</span><br><span class="line">       if (corePoolSize &lt; 0 ||</span><br><span class="line">           maximumPoolSize &lt;= 0 ||</span><br><span class="line">           maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">           keepAliveTime &lt; 0)</span><br><span class="line">           throw new IllegalArgumentException();</span><br><span class="line">       if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">           throw new NullPointerException();</span><br><span class="line">       this.corePoolSize = corePoolSize;</span><br><span class="line">       this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">       this.workQueue = workQueue;</span><br><span class="line">       this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">       this.threadFactory = threadFactory;</span><br><span class="line">       this.handler = handler;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h4><p>线程池中的核心线程数，当你提交一个任务时，线程池会创建一个新线程执行任务，直到当前线程数量等于你定义的corePoolSize；如果当前的线程数为corePoolSize，继续提交的任务会被保留到阻塞队列中，等待被执行。</p>
<h4 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h4><p>线程中允许的最大线程数。如果阻塞队列满了，且继续提交任务的时候，则创建新的线程执行任务，前提是当前线程数必须小于maximumPoolSize。maximumPoolSize必须大于corePoolSize。</p>
<h4 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h4><p>线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间；默认情况下，该参数只在线程数大于corePoolSize时才会有用。</p>
<h4 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h4><p>keepAliveTime的单位</p>
<h4 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h4><p>用来保存等待被执行的任务的阻塞队列，且任务必须实现Runnable接口，在JDK中提供了如下阻塞队列：<br>1、ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；<br>2、LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；<br>3、SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene；<br>4、priorityBlockingQuene：具有优先级的无界阻塞队列；</p>
<h4 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h4><p>创建线程的工厂，通过自定义的线程工程可以给每个线程创建一个具有辨识度的名字。（位于ThreadFactory实现类Executors的内部类DeaultThreadFactory）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DefaultThreadFactory() &#123;</span><br><span class="line">           SecurityManager s = System.getSecurityManager();</span><br><span class="line">           group = (s != null) ? s.getThreadGroup() :</span><br><span class="line">                                 Thread.currentThread().getThreadGroup();</span><br><span class="line">           namePrefix = &quot;pool-&quot; +</span><br><span class="line">                         poolNumber.getAndIncrement() +</span><br><span class="line">                        &quot;-thread-&quot;;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h4 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h4><p>线程池饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略。</p>
<p>1、AbortPolicy：直接抛出异常，默认策略；<br>2、CallerRunsPolicy：用调用者所在的线程来执行任务；<br>3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；<br>4、DiscardPolicy：直接丢弃任务；<br>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p>
<h2 id="核心代码流程"><a href="#核心代码流程" class="headerlink" title="核心代码流程"></a>核心代码流程</h2><h3 id="execute-–-提交任务"><a href="#execute-–-提交任务" class="headerlink" title="execute() – 提交任务"></a>execute() – 提交任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Executes the given task sometime in the future.  The task</span><br><span class="line">     * may execute in a new thread or in an existing pooled thread.</span><br><span class="line">     * 在未来某个时刻执行给定的任务。这个任务用一个新的线程执行，或者用一个线程池中已存在的线程执行</span><br><span class="line">     *</span><br><span class="line">     * If the task cannot be submitted for execution, either because this</span><br><span class="line">     * executor has been shutdown or because its capacity has been reached,</span><br><span class="line">     * the task is handled by the current &#123;@code RejectedExecutionHandler&#125;.</span><br><span class="line">     *如果任务无法被提交执行，要么是因为这个Executor已经被shutdown关闭，要么是已经达到其容量上限，任务会被当前的RejectedExecutionHandler处理</span><br><span class="line">     * @param command the task to execute</span><br><span class="line">     * @throws RejectedExecutionException at discretion of</span><br><span class="line">     *         &#123;@code RejectedExecutionHandler&#125;, if the task</span><br><span class="line">     *         cannot be accepted for execution</span><br><span class="line">     * @throws NullPointerException if &#123;@code command&#125; is null</span><br><span class="line">     */</span><br><span class="line">    public void execute(Runnable command) &#123;</span><br><span class="line">        if (command == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        /*</span><br><span class="line">         * Proceed in 3 steps:</span><br><span class="line">         *</span><br><span class="line">         * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="line">         * start a new thread with the given command as its first</span><br><span class="line">         * task.  The call to addWorker atomically checks runState and</span><br><span class="line">         * workerCount, and so prevents false alarms that would add</span><br><span class="line">         * threads when it shouldn&apos;t, by returning false.</span><br><span class="line">         * 如果运行的线程少于corePoolSize，尝试开启一个新线程去运行command，command作为这个线程的第一个任务</span><br><span class="line">         *</span><br><span class="line">         * 2. If a task can be successfully queued, then we still need</span><br><span class="line">         * to double-check whether we should have added a thread</span><br><span class="line">         * (because existing ones died since last checking) or that</span><br><span class="line">         * the pool shut down since entry into this method. So we</span><br><span class="line">         * recheck state and if necessary roll back the enqueuing if</span><br><span class="line">         * stopped, or start a new thread if there are none.</span><br><span class="line">         * 如果任务成功放入队列，我们仍需要一个双重校验去确认是否应该新建一个线程（因为可能存在有些线程在我们上次检查后死了） 或者 从我们进入这个方法后，pool被关闭了</span><br><span class="line">         * 所以我们需要再次检查state，如果线程池停止了需要回滚入队列，如果池中没有线程了，新开启 一个线程</span><br><span class="line">         * 3. If we cannot queue task, then we try to add a new</span><br><span class="line">         * thread.  If it fails, we know we are shut down or saturated</span><br><span class="line">         * and so reject the task.</span><br><span class="line">         */</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        if (workerCountOf(c) &lt; corePoolSize) &#123; //如果当前线程数少于coolPoolSize</span><br><span class="line">        //addWoker()操作成功，返回</span><br><span class="line">            if (addWorker(command, true))</span><br><span class="line">                return;</span><br><span class="line">         	/**</span><br><span class="line">         	 * 失败的原因可能是：</span><br><span class="line">         		     * 1、线程池已经shutdown，shutdown的线程池不再接收新任务</span><br><span class="line">         		     * 2、workerCountOf(c) &lt; corePoolSize 判断后，由于并发，别的线程先创建了worker线程，导致workerCount&gt;=corePoolSize</span><br><span class="line">         		    */</span><br><span class="line">            c = ctl.get();//每次用到c之前都需刷新一次c</span><br><span class="line">        &#125;</span><br><span class="line">        //如果线程池是Running状态，且线程添加到阻塞队列中成功</span><br><span class="line">        if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            int recheck = ctl.get();//再次校验位</span><br><span class="line">            /**</span><br><span class="line">         		     * 再次校验放入workerQueue中的任务是否能被执行</span><br><span class="line">          		      * 1、如果线程池不是运行状态了，应该拒绝添加新任务，从workQueue中删除任务</span><br><span class="line">         		     * 2、如果线程池是运行状态，或者从workQueue中删除任务失败（刚好有一个线程执行完毕，并消耗了这个任务），确保还有线程执行任务（只要有一个就够了）</span><br><span class="line">                              */</span><br><span class="line">         //如果再次校验过程中，线程池不是RUNNING状态，并且remove(command)--workQueue.remove()成功，拒绝当前command</span><br><span class="line">            if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            //如果当前worker数量为0，通过addWorker(null, false)创建一个线程，其任务为null</span><br><span class="line">                          //为什么只检查运行的worker数量是不是0呢？？ 为什么不和corePoolSize比较呢？？</span><br><span class="line">                         //只保证有一个worker线程可以从queue中获取任务执行就行了？？</span><br><span class="line">                        //因为只要还有活动的worker线程，就可以消费workerQueue中的任务</span><br><span class="line">            else if (workerCountOf(recheck) == 0)</span><br><span class="line">                addWorker(null, false);</span><br><span class="line">        &#125;</span><br><span class="line">         /**</span><br><span class="line">                      * 3、如果线程池不是running状态 或者 无法入队列</span><br><span class="line">                      *   尝试开启新线程，扩容至maxPoolSize，如果addWork(command, false)失败了，拒绝当前command</span><br><span class="line">                      */</span><br><span class="line">        else if (!addWorker(command, false))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="addWorker-–-添加worker线程"><a href="#addWorker-–-添加worker线程" class="headerlink" title="addWorker() – 添加worker线程"></a>addWorker() – 添加worker线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Checks if a new worker can be added with respect to current</span><br><span class="line">     * pool state and the given bound (either core or maximum). If so,</span><br><span class="line">     * the worker count is adjusted accordingly, and, if possible, a</span><br><span class="line">     * new worker is created and started, running firstTask as its</span><br><span class="line">     * first task. This method returns false if the pool is stopped or</span><br><span class="line">     * eligible to shut down. It also returns false if the thread</span><br><span class="line">     * factory fails to create a thread when asked.  If the thread</span><br><span class="line">     * creation fails, either due to the thread factory returning</span><br><span class="line">     * null, or due to an exception (typically OutOfMemoryError in</span><br><span class="line">     * Thread.start()), we roll back cleanly.</span><br><span class="line">     * 检查根据当前线程池的状态和给定的边界(core or maximum)是否可以创建一个新的worker</span><br><span class="line">     * 如果是这样的话，worker的数量做相应的调整，如果可能的话，创建一个新的worker并启动，参数中的firstTask作为worker的第一个任务</span><br><span class="line">     * 如果方法返回false，可能因为pool已经关闭或者调用过了shutdown</span><br><span class="line">     * 如果线程工厂创建线程失败，也会失败，返回false</span><br><span class="line">     * 如果线程创建失败，要么是因为线程工厂返回null，要么是发生了OutOfMemoryError</span><br><span class="line"> 	 *</span><br><span class="line">     * @param firstTask the task the new thread should run first (or</span><br><span class="line">     * null if none). Workers are created with an initial first task</span><br><span class="line">     * (in method execute()) to bypass queuing when there are fewer</span><br><span class="line">     * than corePoolSize threads (in which case we always start one),</span><br><span class="line">     * or when the queue is full (in which case we must bypass queue).</span><br><span class="line">     * Initially idle threads are usually created via</span><br><span class="line">     * prestartCoreThread or to replace other dying workers.</span><br><span class="line">     *</span><br><span class="line">     * @param core if true use corePoolSize as bound, else</span><br><span class="line">     * maximumPoolSize. (A boolean indicator is used here rather than a</span><br><span class="line">     * value to ensure reads of fresh values after checking other pool</span><br><span class="line">     * state).</span><br><span class="line">     * @return true if successful</span><br><span class="line">     */</span><br><span class="line">    private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    	//外部循环，负责线程池状态</span><br><span class="line">        retry:</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int c = ctl.get();</span><br><span class="line">            int rs = runStateOf(c); // 状态</span><br><span class="line"></span><br><span class="line">            // Check if queue empty only if necessary.</span><br><span class="line">            /**</span><br><span class="line">         	 * 线程池的state越小越是运行状态，runnbale=-1，shutdown=0,stop=1,tidying=2，terminated=3</span><br><span class="line">             * 1、如果线程池state已经至少是shutdown状态了</span><br><span class="line">             * 2、并且以下3个条件任意一个是false</span><br><span class="line">             *   rs == SHUTDOWN         （隐含：rs&gt;=SHUTDOWN）false情况： 线程池状态已经超过shutdown，可能是stop、tidying、terminated其中一个，即线程池已经终止</span><br><span class="line">             *   firstTask == null      （隐含：rs==SHUTDOWN）false情况： firstTask不为空，rs==SHUTDOWN 且 firstTask不为空，return false，场景是在线程池已经shutdown后，还要添加新的任务，拒绝</span><br><span class="line">             *   ! workQueue.isEmpty()  （隐含：rs==SHUTDOWN，firstTask==null）false情况： workQueue为空，当firstTask为空时是为了创建一个没有任务的线程，再从workQueue中获取任务，如果workQueue已经为空，那么就没有添加新worker线程的必要了</span><br><span class="line">             * return false，即无法addWorker()</span><br><span class="line">             */</span><br><span class="line">            if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == null &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                return false;</span><br><span class="line">			//内层村还，负责worker数量+1</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int wc = workerCountOf(c);//worker数量</span><br><span class="line">                //如果worker数量&gt;线程池最大上限CAPACITY（即使用int低29位可以容纳的最大值）</span><br><span class="line">            	//或者( worker数量&gt;corePoolSize 或  worker数量&gt;maximumPoolSize )，即已经超过了给定的边界</span><br><span class="line">                if (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    return false;</span><br><span class="line">                //调用unsafe CAS操作，使得worker数量+1，成功则跳出retry循环</span><br><span class="line">                if (compareAndIncrementWorkerCount(c))//线程数量+1</span><br><span class="line">                    break retry;</span><br><span class="line">                //CAS worker数量+1失败，再次读取ctl</span><br><span class="line">                c = ctl.get();  // Re-read ctl</span><br><span class="line">                //如果状态不等于之前获取的state，跳出内层循环，继续去外层循环判断</span><br><span class="line">                if (runStateOf(c) != rs)</span><br><span class="line">                    continue retry;</span><br><span class="line">                // else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">                // else CAS失败时因为workerCount改变了，继续内层循环尝试CAS对worker数量+1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		/**</span><br><span class="line">         * worker数量+1成功的后续操作</span><br><span class="line">     	 * 添加到workers Set集合，并启动worker线程</span><br><span class="line">     	 */</span><br><span class="line">        boolean workerStarted = false;</span><br><span class="line">        boolean workerAdded = false;</span><br><span class="line">        Worker w = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            w = new Worker(firstTask);</span><br><span class="line">            final Thread t = w.thread;</span><br><span class="line">            if (t != null) &#123;</span><br><span class="line">                final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">                mainLock.lock();//线程池主锁</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 以下代码开始上锁</span><br><span class="line">                    // Recheck while holding lock.</span><br><span class="line">                    // Back out on ThreadFactory failure or if</span><br><span class="line">                    // shut down before lock acquired.</span><br><span class="line">                    int rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                    if (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">                        if (t.isAlive()) // precheck that t is startable</span><br><span class="line">                            throw new IllegalThreadStateException();</span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        int s = workers.size();</span><br><span class="line">                        if (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    mainLock.unlock(); //释放锁</span><br><span class="line">                &#125;</span><br><span class="line">                //如果往HashSet中添加worker成功，启动线程</span><br><span class="line">                if (workerAdded) &#123;</span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        return workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>addWorker(Runnable firstTask, boolean core)</strong><br><strong>参数：</strong><br>​    firstTask：    worker线程的初始任务，可以为空<br>​    core：           true：将corePoolSize作为上限，false：将maximumPoolSize作为上限<br><strong>addWorker方法有4种传参的方式：</strong></p>
<p>​    1、addWorker(command, true)</p>
<p>​    2、addWorker(command, false)</p>
<p>​    3、addWorker(null, false)</p>
<p>​    4、addWorker(null, true)</p>
<p>在execute方法中就使用了前3种，结合这个核心方法进行以下分析<br>​    第一个：线程数小于corePoolSize时，放一个需要处理的task进Workers Set。如果Workers Set长度超过corePoolSize，就返回false<br>​    第二个：当队列被放满时，就尝试将这个新来的task直接放入Workers Set，而此时Workers Set的长度限制是maximumPoolSize。如果线程池也满了的话就返回false<br>​    第三个：放入一个空的task进workers Set，长度限制是maximumPoolSize。这样一个task为空的worker在线程执行的时候会去任务队列里拿任务，这样就相当于创建了一个新的线程，只是没有马上分配任务<br>​    第四个：这个方法就是放一个null的task进Workers Set，而且是在小于corePoolSize时，如果此时Set中的数量已经达到corePoolSize那就返回false，什么也不干。实际使用中是在prestartAllCoreThreads()方法，这个方法用来为线程池预先启动corePoolSize个worker等待从workQueue中获取任务执行<br><strong>执行流程：</strong><br>1、判断线程池当前是否为可以添加worker线程的状态，可以则继续下一步，不可以return false：<br>​    A、线程池状态&gt;shutdown，可能为stop、tidying、terminated，不能添加worker线程<br>​    B、线程池状态==shutdown，firstTask不为空，不能添加worker线程，因为shutdown状态的线程池不接收新任务<br>​    C、线程池状态==shutdown，firstTask==null，workQueue为空，不能添加worker线程，因为firstTask为空是为了添加一个没有任务的线程再从workQueue获取task，而workQueue为空，说明添加无任务线程已经没有意义<br>2、线程池当前线程数量是否超过上限（corePoolSize 或 maximumPoolSize），超过了return false，没超过则对workerCount+1，继续下一步<br>3、在线程池的ReentrantLock保证下，向Workers Set中添加新创建的worker实例，添加完成后解锁，并启动worker线程，如果这一切都成功了，return true，如果添加worker入Set失败或启动失败，调用addWorkerFailed()逻辑</p>
<h3 id="worker-–-内部类"><a href="#worker-–-内部类" class="headerlink" title="worker() – 内部类"></a>worker() – 内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Class Worker mainly maintains interrupt control state for</span><br><span class="line"> * threads running tasks, along with other minor bookkeeping.</span><br><span class="line"> * This class opportunistically extends AbstractQueuedSynchronizer</span><br><span class="line"> * to simplify acquiring and releasing a lock surrounding each</span><br><span class="line"> * task execution.  This protects against interrupts that are</span><br><span class="line"> * intended to wake up a worker thread waiting for a task from</span><br><span class="line"> * instead interrupting a task being run.  We implement a simple</span><br><span class="line"> * non-reentrant mutual exclusion lock rather than use</span><br><span class="line"> * ReentrantLock because we do not want worker tasks to be able to</span><br><span class="line"> * reacquire the lock when they invoke pool control methods like</span><br><span class="line"> * setCorePoolSize.  Additionally, to suppress interrupts until</span><br><span class="line"> * the thread actually starts running tasks, we initialize lock</span><br><span class="line"> * state to a negative value, and clear it upon start (in</span><br><span class="line"> * runWorker).</span><br><span class="line"> * </span><br><span class="line"> * Worker类大体上管理着运行线程的中断状态 和 一些指标</span><br><span class="line"> * Worker类投机取巧的继承了AbstractQueuedSynchronizer来简化在执行任务时的获取、释放锁</span><br><span class="line"> * 这样防止了中断在运行中的任务，只会唤醒(中断)在等待从workQueue中获取任务的线程</span><br><span class="line"> * 解释：</span><br><span class="line"> *   为什么不直接执行execute(command)提交的command，而要在外面包一层Worker呢？？</span><br><span class="line"> *   主要是为了控制中断</span><br><span class="line"> *   用什么控制？？</span><br><span class="line"> *   用AQS锁，当运行时上锁，就不能中断，TreadPoolExecutor的shutdown()方法中断前都要获取worker锁</span><br><span class="line"> *   只有在等待从workQueue中获取任务getTask()时才能中断</span><br><span class="line"> * worker实现了一个简单的不可重入的互斥锁，而不是用ReentrantLock可重入锁</span><br><span class="line"> * 因为我们不想让在调用比如setCorePoolSize()这种线程池控制方法时可以再次获取锁(重入)</span><br><span class="line"> * 解释：</span><br><span class="line"> *   setCorePoolSize()时可能会interruptIdleWorkers()，在对一个线程interrupt时会要w.tryLock()</span><br><span class="line"> *   如果可重入，就可能会在对线程池操作的方法中中断线程，类似方法还有：</span><br><span class="line"> *   setMaximumPoolSize()</span><br><span class="line"> *   setKeppAliveTime()</span><br><span class="line"> *   allowCoreThreadTimeOut()</span><br><span class="line"> *   shutdown()</span><br><span class="line"> * 此外，为了让线程真正开始后才可以中断，初始化lock状态为负值(-1)，在开始runWorker()时将state置为0，而state&gt;=0才可以中断</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * Worker继承了AQS，实现了Runnable，说明其既是一个可运行的任务，也是一把锁（不可重入）</span><br><span class="line"> */</span><br><span class="line">private final class Worker</span><br><span class="line">    extends AbstractQueuedSynchronizer</span><br><span class="line">    implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * This class will never be serialized, but we provide a</span><br><span class="line">     * serialVersionUID to suppress a javac warning.</span><br><span class="line">     */</span><br><span class="line">    private static final long serialVersionUID = 6138294804551838833L;</span><br><span class="line"> </span><br><span class="line">    /** Thread this worker is running in.  Null if factory fails. */</span><br><span class="line">    final Thread thread; //利用ThreadFactory和 Worker这个Runnable创建的线程对象</span><br><span class="line">     </span><br><span class="line">    /** Initial task to run.  Possibly null. */</span><br><span class="line">    Runnable firstTask;</span><br><span class="line">     </span><br><span class="line">    /** Per-thread task counter */</span><br><span class="line">    volatile long completedTasks;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * Creates with given first task and thread from ThreadFactory.</span><br><span class="line">     * @param firstTask the first task (null if none)</span><br><span class="line">     */</span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        //设置AQS的同步状态private volatile int state，是一个计数器，大于0代表锁已经被获取</span><br><span class="line">        setState(-1); // inhibit interrupts until runWorker </span><br><span class="line">                      // 在调用runWorker()前，禁止interrupt中断，在interruptIfStarted()方法中会判断 getState()&gt;=0</span><br><span class="line">        this.firstTask = firstTask;</span><br><span class="line">        this.thread = getThreadFactory().newThread(this); //根据当前worker创建一个线程对象</span><br><span class="line">                                                          //当前worker本身就是一个runnable任务，也就是不会用参数的firstTask创建线程，而是调用当前worker.run()时调用firstTask.run()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /** Delegates main run loop to outer runWorker  */</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        runWorker(this); //runWorker()是ThreadPoolExecutor的方法</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // Lock methods</span><br><span class="line">    //</span><br><span class="line">    // The value 0 represents the unlocked state. 0代表“没被锁定”状态</span><br><span class="line">    // The value 1 represents the locked state. 1代表“锁定”状态</span><br><span class="line"> </span><br><span class="line">    protected boolean isHeldExclusively() &#123;</span><br><span class="line">        return getState() != 0;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 尝试获取锁</span><br><span class="line">     * 重写AQS的tryAcquire()，AQS本来就是让子类来实现的</span><br><span class="line">     */</span><br><span class="line">    protected boolean tryAcquire(int unused) &#123;</span><br><span class="line">        //尝试一次将state从0设置为1，即“锁定”状态，但由于每次都是state 0-&gt;1，而不是+1，那么说明不可重入</span><br><span class="line">        //且state==-1时也不会获取到锁</span><br><span class="line">        if (compareAndSetState(0, 1)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread()); //设置exclusiveOwnerThread=当前线程</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 尝试释放锁</span><br><span class="line">     * 不是state-1，而是置为0</span><br><span class="line">     */</span><br><span class="line">    protected boolean tryRelease(int unused) &#123;</span><br><span class="line">        setExclusiveOwnerThread(null); </span><br><span class="line">        setState(0);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void lock()        &#123; acquire(1); &#125;</span><br><span class="line">    public boolean tryLock()  &#123; return tryAcquire(1); &#125;</span><br><span class="line">    public void unlock()      &#123; release(1); &#125;</span><br><span class="line">    public boolean isLocked() &#123; return isHeldExclusively(); &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 中断（如果运行）</span><br><span class="line">     * shutdownNow时会循环对worker线程执行</span><br><span class="line">     * 且不需要获取worker锁，即使在worker运行时也可以中断</span><br><span class="line">     */</span><br><span class="line">    void interruptIfStarted() &#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        //如果state&gt;=0、t!=null、且t没有被中断</span><br><span class="line">        //new Worker()时state==-1，说明不能中断</span><br><span class="line">        if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Worker类</strong><br>Worker类本身既实现了Runnable，又继承了AbstractQueuedSynchronizer（以下简称AQS），所以其既是一个可执行的任务，又可以达到锁的效果<br><strong>new Worker()</strong><br>1、将AQS的state置为-1，在runWoker()前不允许中断<br>2、待执行的任务会以参数传入，并赋予firstTask<br>3、用Worker这个Runnable创建Thread</p>
<p>之所以Worker自己实现Runnable，并创建Thread，在firstTask外包一层，是因为要通过Worker控制中断，而firstTask这个工作任务只是负责执行业务<br><strong>Worker控制中断主要有以下几方面：</strong><br>1、初始AQS状态为-1，此时不允许中断interrupt()，只有在worker线程启动了，执行了runWoker()，将state置为0，才能中断<br>​    不允许中断体现在：<br>​    A、shutdown()线程池时，会对每个worker tryLock()上锁，而Worker类这个AQS的tryAcquire()方法是固定将state从0-&gt;1，故初始状态state==-1时tryLock()失败，没发interrupt()<br>​    B、shutdownNow()线程池时，不用tryLock()上锁，但调用worker.interruptIfStarted()终止worker，interruptIfStarted()也有state&gt;0才能interrupt的逻辑<br>2、为了防止某种情况下，在运行中的worker被中断，runWorker()每次运行任务时都会lock()上锁，而shutdown()这类可能会终止worker的操作需要先获取worker的锁，这样就防止了中断正在运行的线程</p>
<p>Worker实现的AQS为不可重入锁，为了是在获得worker锁的情况下再进入其它一些需要加锁的方法</p>
<p><strong>Worker和Task的区别：</strong><br>Worker是线程池中的线程，而Task虽然是runnable，但是并没有真正执行，只是被Worker调用了run方法，后面会看到这部分的实现。</p>
<h3 id="runWorker-–-执行任务"><a href="#runWorker-–-执行任务" class="headerlink" title="runWorker() – 执行任务"></a>runWorker() – 执行任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Main worker run loop.  Repeatedly gets tasks from queue and</span><br><span class="line"> * executes them, while coping with a number of issues:</span><br><span class="line"> * 重复的从队列中获取任务并执行，同时应对一些问题：</span><br><span class="line"> *</span><br><span class="line"> * 1. We may start out with an initial task, in which case we</span><br><span class="line"> * don&apos;t need to get the first one. Otherwise, as long as pool is</span><br><span class="line"> * running, we get tasks from getTask. If it returns null then the</span><br><span class="line"> * worker exits due to changed pool state or configuration</span><br><span class="line"> * parameters.  Other exits result from exception throws in</span><br><span class="line"> * external code, in which case completedAbruptly holds, which</span><br><span class="line"> * usually leads processWorkerExit to replace this thread.</span><br><span class="line"> * 我们可能使用一个初始化任务开始，即firstTask为null</span><br><span class="line"> * 然后只要线程池在运行，我们就从getTask()获取任务</span><br><span class="line"> * 如果getTask()返回null，则worker由于改变了线程池状态或参数配置而退出</span><br><span class="line"> * 其它退出因为外部代码抛异常了，这会使得completedAbruptly为true，这会导致在processWorkerExit()方法中替换当前线程</span><br><span class="line"> *</span><br><span class="line"> * 2. Before running any task, the lock is acquired to prevent</span><br><span class="line"> * other pool interrupts while the task is executing, and</span><br><span class="line"> * clearInterruptsForTaskRun called to ensure that unless pool is</span><br><span class="line"> * stopping, this thread does not have its interrupt set.</span><br><span class="line"> * 在任何任务执行之前，都需要对worker加锁去防止在任务运行时，其它的线程池中断操作</span><br><span class="line"> * clearInterruptsForTaskRun保证除非线程池正在stoping，线程不会被设置中断标示</span><br><span class="line"> *</span><br><span class="line"> * 3. Each task run is preceded by a call to beforeExecute, which</span><br><span class="line"> * might throw an exception, in which case we cause thread to die</span><br><span class="line"> * (breaking loop with completedAbruptly true) without processing</span><br><span class="line"> * the task.</span><br><span class="line"> * 每个任务执行前会调用beforeExecute()，其中可能抛出一个异常，这种情况下会导致线程die（跳出循环，且completedAbruptly==true），没有执行任务</span><br><span class="line"> * 因为beforeExecute()的异常没有cache住，会上抛，跳出循环</span><br><span class="line"> *</span><br><span class="line"> * 4. Assuming beforeExecute completes normally, we run the task,</span><br><span class="line"> * gathering any of its thrown exceptions to send to</span><br><span class="line"> * afterExecute. We separately handle RuntimeException, Error</span><br><span class="line"> * (both of which the specs guarantee that we trap) and arbitrary</span><br><span class="line"> * Throwables.  Because we cannot rethrow Throwables within</span><br><span class="line"> * Runnable.run, we wrap them within Errors on the way out (to the</span><br><span class="line"> * thread&apos;s UncaughtExceptionHandler).  Any thrown exception also</span><br><span class="line"> * conservatively causes thread to die.</span><br><span class="line"> * 假定beforeExecute()正常完成，我们执行任务</span><br><span class="line"> * 汇总任何抛出的异常并发送给afterExecute(task, thrown)</span><br><span class="line"> * 因为我们不能在Runnable.run()方法中重新上抛Throwables，我们将Throwables包装到Errors上抛（会到线程的UncaughtExceptionHandler去处理）</span><br><span class="line"> * 任何上抛的异常都会导致线程die</span><br><span class="line"> *</span><br><span class="line"> * 5. After task.run completes, we call afterExecute, which may</span><br><span class="line"> * also throw an exception, which will also cause thread to</span><br><span class="line"> * die. According to JLS Sec 14.20, this exception is the one that</span><br><span class="line"> * will be in effect even if task.run throws.</span><br><span class="line"> * 任务执行结束后，调用afterExecute()，也可能抛异常，也会导致线程die</span><br><span class="line"> * 根据JLS Sec 14.20，这个异常（finally中的异常）会生效</span><br><span class="line"> *</span><br><span class="line"> * The net effect of the exception mechanics is that afterExecute</span><br><span class="line"> * and the thread&apos;s UncaughtExceptionHandler have as accurate</span><br><span class="line"> * information as we can provide about any problems encountered by</span><br><span class="line"> * user code.</span><br><span class="line"> *</span><br><span class="line"> * @param w the worker</span><br><span class="line"> */</span><br><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = null;</span><br><span class="line">    w.unlock(); // allow interrupts</span><br><span class="line">                // new Worker()是state==-1，此处是调用Worker类的tryRelease()方法，将state置为0， 而interruptIfStarted()中只有state&gt;=0才允许调用中断</span><br><span class="line">    boolean completedAbruptly = true; //是否“突然完成”，如果是由于异常导致的进入finally，那么completedAbruptly==true就是突然完成的</span><br><span class="line">    try &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 如果task不为null，或者从阻塞队列中getTask()不为null</span><br><span class="line">         */</span><br><span class="line">        while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">            w.lock(); //上锁，不是为了防止并发执行任务，为了在shutdown()时不终止正在运行的worker</span><br><span class="line">             </span><br><span class="line">            // If pool is stopping, ensure thread is interrupted;</span><br><span class="line">            // if not, ensure thread is not interrupted.  This</span><br><span class="line">            // requires a recheck in second case to deal with</span><br><span class="line">            // shutdownNow race while clearing interrupt</span><br><span class="line">            /**</span><br><span class="line">             * clearInterruptsForTaskRun操作</span><br><span class="line">             * 确保只有在线程stoping时，才会被设置中断标示，否则清除中断标示</span><br><span class="line">             * 1、如果线程池状态&gt;=stop，且当前线程没有设置中断状态，wt.interrupt()</span><br><span class="line">             * 2、如果一开始判断线程池状态&lt;stop，但Thread.interrupted()为true，即线程已经被中断，又清除了中断标示，再次判断线程池状态是否&gt;=stop</span><br><span class="line">             *   是，再次设置中断标示，wt.interrupt()</span><br><span class="line">             *   否，不做操作，清除中断标示后进行后续步骤</span><br><span class="line">             */</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt(); //当前线程调用interrupt()中断</span><br><span class="line">             </span><br><span class="line">            try &#123;</span><br><span class="line">                //执行前（子类实现）</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                 </span><br><span class="line">                Throwable thrown = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; </span><br><span class="line">                catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; </span><br><span class="line">                catch (Error x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; </span><br><span class="line">                catch (Throwable x) &#123;</span><br><span class="line">                    thrown = x; throw new Error(x);</span><br><span class="line">                &#125; </span><br><span class="line">                finally &#123;</span><br><span class="line">                    //执行后（子类实现）</span><br><span class="line">                    afterExecute(task, thrown); //这里就考验catch和finally的执行顺序了，因为要以thrown为参数</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            finally &#123;</span><br><span class="line">                task = null; //task置为null</span><br><span class="line">                w.completedTasks++; //完成任务数+1</span><br><span class="line">                w.unlock(); //解锁</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        completedAbruptly = false;</span><br><span class="line">    &#125; </span><br><span class="line">    finally &#123;</span><br><span class="line">        //处理worker的退出</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>runWorker(Worker w)</strong><br><strong>执行流程：</strong><br>1、Worker线程启动后，通过Worker类的run()方法调用runWorker(this)<br>2、执行任务之前，首先worker.unlock()，将AQS的state置为0，允许中断当前worker线程<br>3、开始执行firstTask，调用task.run()，在执行任务前会上锁wroker.lock()，在执行完任务后会解锁，为了防止在任务运行时被线程池一些中断操作中断<br>4、在任务执行前后，可以根据业务场景自定义beforeExecute() 和 afterExecute()方法<br>5、无论在beforeExecute()、task.run()、afterExecute()发生异常上抛，都会导致worker线程终止，进入processWorkerExit()处理worker退出的流程<br>6、如正常执行完当前task后，会通过getTask()从阻塞队列中获取新任务，当队列中没有任务，且获取任务超时，那么当前worker也会进入退出流程</p>
<h3 id="getTask-–-获取任务"><a href="#getTask-–-获取任务" class="headerlink" title="getTask() – 获取任务"></a>getTask() – 获取任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Performs blocking or timed wait for a task, depending on</span><br><span class="line"> * current configuration settings, or returns null if this worker</span><br><span class="line"> * must exit because of any of:  以下情况会返回null</span><br><span class="line"> * 1. There are more than maximumPoolSize workers (due to</span><br><span class="line"> *    a call to setMaximumPoolSize).</span><br><span class="line"> *    超过了maximumPoolSize设置的线程数量（因为调用了setMaximumPoolSize()）</span><br><span class="line"> * 2. The pool is stopped.</span><br><span class="line"> *    线程池被stop</span><br><span class="line"> * 3. The pool is shutdown and the queue is empty.</span><br><span class="line"> *    线程池被shutdown，并且workQueue空了</span><br><span class="line"> * 4. This worker timed out waiting for a task, and timed-out</span><br><span class="line"> *    workers are subject to termination (that is,</span><br><span class="line"> *    &#123;@code allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;)</span><br><span class="line"> *    both before and after the timed wait.</span><br><span class="line"> *    线程等待任务超时</span><br><span class="line"> *</span><br><span class="line"> * @return task, or null if the worker must exit, in which case</span><br><span class="line"> *         workerCount is decremented</span><br><span class="line"> *         返回null表示这个worker要结束了，这种情况下workerCount-1</span><br><span class="line"> */</span><br><span class="line">private Runnable getTask() &#123;</span><br><span class="line">    boolean timedOut = false; // Did the last poll() time out?</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 外层循环</span><br><span class="line">     * 用于判断线程池状态</span><br><span class="line">     */</span><br><span class="line">    retry:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line"> </span><br><span class="line">        // Check if queue empty only if necessary.</span><br><span class="line">        /**</span><br><span class="line">         * 对线程池状态的判断，两种情况会workerCount-1，并且返回null</span><br><span class="line">         * 线程池状态为shutdown，且workQueue为空（反映了shutdown状态的线程池还是要执行workQueue中剩余的任务的）</span><br><span class="line">         * 线程池状态为stop（shutdownNow()会导致变成STOP）（此时不用考虑workQueue的情况）</span><br><span class="line">         */</span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount(); //循环的CAS减少worker数量，直到成功</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        boolean timed;      // Are workers subject to culling?</span><br><span class="line">                            // 是否需要定时从workQueue中获取</span><br><span class="line">         </span><br><span class="line">        /**</span><br><span class="line">         * 内层循环</span><br><span class="line">         * 要么break去workQueue获取任务</span><br><span class="line">         * 要么超时了，worker count-1</span><br><span class="line">         */</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int wc = workerCountOf(c);</span><br><span class="line">            timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; //allowCoreThreadTimeOut默认为false</span><br><span class="line">                                                                 //如果allowCoreThreadTimeOut为true，说明corePoolSize和maximum都需要定时</span><br><span class="line">             </span><br><span class="line">            //如果当前执行线程数&lt;maximumPoolSize，并且timedOut 和 timed 任一为false，跳出循环，开始从workQueue获取任务</span><br><span class="line">            if (wc &lt;= maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed))</span><br><span class="line">                break;</span><br><span class="line">             </span><br><span class="line">            /**</span><br><span class="line">             * 如果到了这一步，说明要么线程数量超过了maximumPoolSize（可能maximumPoolSize被修改了）</span><br><span class="line">             * 要么既需要计时timed==true，也超时了timedOut==true</span><br><span class="line">             * worker数量-1，减一执行一次就行了，然后返回null，在runWorker()中会有逻辑减少worker线程</span><br><span class="line">             * 如果本次减一失败，继续内层循环再次尝试减一</span><br><span class="line">             */</span><br><span class="line">            if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                return null;</span><br><span class="line">             </span><br><span class="line">            //如果减数量失败，再次读取ctl</span><br><span class="line">            c = ctl.get();  // Re-read ctl</span><br><span class="line">             </span><br><span class="line">            //如果线程池运行状态发生变化，继续外层循环</span><br><span class="line">            //如果状态没变，继续内层循环</span><br><span class="line">            if (runStateOf(c) != rs)</span><br><span class="line">                continue retry;</span><br><span class="line">            // else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            //poll() - 使用  LockSupport.parkNanos(this, nanosTimeout) 挂起一段时间，interrupt()时不会抛异常，但会有中断响应</span><br><span class="line">            //take() - 使用 LockSupport.park(this) 挂起，interrupt()时不会抛异常，但会有中断响应</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :    //大于corePoolSize</span><br><span class="line">                workQueue.take();                                        //小于等于corePoolSize</span><br><span class="line">             </span><br><span class="line">            //如获取到了任务就返回</span><br><span class="line">            if (r != null)</span><br><span class="line">                return r;</span><br><span class="line">             </span><br><span class="line">            //没有返回，说明超时，那么在下一次内层循环时会进入worker count减一的步骤</span><br><span class="line">            timedOut = true;</span><br><span class="line">        &#125; </span><br><span class="line">        /**</span><br><span class="line">              * blockingQueue的take()阻塞使用LockSupport.park(this)进入wait状态的，对LockSupport.park(this)进行interrupt不会抛异常，但还是会有中断响应</span><br><span class="line">              * 但AQS的ConditionObject的await()对中断状态做了判断，会报告中断状态 reportInterruptAfterWait(interruptMode)</span><br><span class="line">              * 就会上抛InterruptedException，在此处捕获，重新开始循环</span><br><span class="line">              * 如果是由于shutdown()等操作导致的空闲worker中断响应，在外层循环判断状态时，可能return null</span><br><span class="line">              */</span><br><span class="line">        catch (InterruptedException retry) &#123; </span><br><span class="line">            timedOut = false; //响应中断，重新开始，中断状态会被清除</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getTask()</strong><br><strong>执行流程：</strong><br>1、首先判断是否可以满足从workQueue中获取任务的条件，不满足return null<br>​    A、线程池状态是否满足：<br>​        （a）shutdown状态 + workQueue为空 或 stop状态，都不满足，因为被shutdown后还是要执行workQueue剩余的任务，但workQueue也为空，就可以退出了<br>​        （b）stop状态，shutdownNow()操作会使线程池进入stop，此时不接受新任务，中断正在执行的任务，workQueue中的任务也不执行了，故return null返回<br>​    B、线程数量是否超过maximumPoolSize 或 获取任务是否超时<br>​        （a）线程数量超过maximumPoolSize可能是线程池在运行时被调用了setMaximumPoolSize()被改变了大小，否则已经addWorker()成功不会超过maximumPoolSize<br>​        （b）如果 当前线程数量&gt;corePoolSize，才会检查是否获取任务超时，这也体现了当线程数量达到maximumPoolSize后，如果一直没有新任务，会逐渐终止worker线程直到corePoolSize<br>2、如果满足获取任务条件，根据是否需要定时获取调用不同方法：<br>​    A、workQueue.poll()：如果在keepAliveTime时间内，阻塞队列还是没有任务，返回null<br>​    B、workQueue.take()：如果阻塞队列为空，当前线程会被挂起等待；当队列中有任务加入时，线程被唤醒，take方法返回任务<br>3、在阻塞从workQueue中获取任务时，可以被interrupt()中断，代码中捕获了InterruptedException，重置timedOut为初始值false，再次执行第1步中的判断，满足就继续获取任务，不满足return null，会进入worker退出的流程</p>
<h3 id="processWorkerExit-–-worker线程退出"><a href="#processWorkerExit-–-worker线程退出" class="headerlink" title="processWorkerExit()  –  worker线程退出"></a>processWorkerExit()  –  worker线程退出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Performs cleanup and bookkeeping for a dying worker. Called</span><br><span class="line"> * only from worker threads. Unless completedAbruptly is set,</span><br><span class="line"> * assumes that workerCount has already been adjusted to account</span><br><span class="line"> * for exit.  This method removes thread from worker set, and</span><br><span class="line"> * possibly terminates the pool or replaces the worker if either</span><br><span class="line"> * it exited due to user task exception or if fewer than</span><br><span class="line"> * corePoolSize workers are running or queue is non-empty but</span><br><span class="line"> * there are no workers.</span><br><span class="line"> *</span><br><span class="line"> * @param w the worker</span><br><span class="line"> * @param completedAbruptly if the worker died due to user exception</span><br><span class="line"> */</span><br><span class="line">private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 1、worker数量-1</span><br><span class="line">     * 如果是突然终止，说明是task执行时异常情况导致，即run()方法执行时发生了异常，那么正在工作的worker线程数量需要-1</span><br><span class="line">     * 如果不是突然终止，说明是worker线程没有task可执行了，不用-1，因为已经在getTask()方法中-1了</span><br><span class="line">     */</span><br><span class="line">    if (completedAbruptly) // If abrupt, then workerCount wasn&apos;t adjusted 代码和注释正好相反啊</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 2、从Workers Set中移除worker</span><br><span class="line">     */</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks; //把worker的完成任务数加到线程池的完成任务数</span><br><span class="line">        workers.remove(w); //从HashSet&lt;Worker&gt;中移除</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 3、在对线程池有负效益的操作时，都需要“尝试终止”线程池</span><br><span class="line">     * 主要是判断线程池是否满足终止的状态</span><br><span class="line">     * 如果状态满足，但还有线程池还有线程，尝试对其发出中断响应，使其能进入退出流程</span><br><span class="line">     * 没有线程了，更新状态为tidying-&gt;terminated</span><br><span class="line">     */</span><br><span class="line">    tryTerminate();</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 4、是否需要增加worker线程</span><br><span class="line">     * 线程池状态是running 或 shutdown</span><br><span class="line">     * 如果当前线程是突然终止的，addWorker()</span><br><span class="line">     * 如果当前线程不是突然终止的，但当前线程数量 &lt; 要维护的线程数量，addWorker()</span><br><span class="line">     * 故如果调用线程池shutdown()，直到workQueue为空前，线程池都会维持corePoolSize个线程，然后再逐渐销毁这corePoolSize个线程</span><br><span class="line">     */</span><br><span class="line">    int c = ctl.get();</span><br><span class="line">    //如果状态是running、shutdown，即tryTerminate()没有成功终止线程池，尝试再添加一个worker</span><br><span class="line">    if (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        //不是突然完成的，即没有task任务可以获取而完成的，计算min，并根据当前worker数量判断是否需要addWorker()</span><br><span class="line">        if (!completedAbruptly) &#123;</span><br><span class="line">            int min = allowCoreThreadTimeOut ? 0 : corePoolSize; //allowCoreThreadTimeOut默认为false，即min默认为corePoolSize</span><br><span class="line">             </span><br><span class="line">            //如果min为0，即不需要维持核心线程数量，且workQueue不为空，至少保持一个线程</span><br><span class="line">            if (min == 0 &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = 1;</span><br><span class="line">             </span><br><span class="line">            //如果线程数量大于最少数量，直接返回，否则下面至少要addWorker一个</span><br><span class="line">            if (workerCountOf(c) &gt;= min)</span><br><span class="line">                return; // replacement not needed</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        //添加一个没有firstTask的worker</span><br><span class="line">        //只要worker是completedAbruptly突然终止的，或者线程数量小于要维护的数量，就新添一个worker线程，即使是shutdown状态</span><br><span class="line">        addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>processWorkerExit(Worker w, boolean completedAbruptly)</strong><br><strong>参数：</strong><br>​    worker：                      要结束的worker<br>​    completedAbruptly： 是否突然完成（是否因为异常退出）<br><strong>执行流程：</strong><br>1、worker数量-1<br>​    A、如果是突然终止，说明是task执行时异常情况导致，即run()方法执行时发生了异常，那么正在工作的worker线程数量需要-1<br>​    B、如果不是突然终止，说明是worker线程没有task可执行了，不用-1，因为已经在getTask()方法中-1了<br>2、从Workers Set中移除worker，删除时需要上锁mainlock<br>3、tryTerminate()：在对线程池有负效益的操作时，都需要“尝试终止”线程池，大概逻辑：<br>​    判断线程池是否满足终止的状态<br>​    A、如果状态满足，但还有线程池还有线程，尝试对其发出中断响应，使其能进入退出流程<br>​    B、没有线程了，更新状态为tidying-&gt;terminated<br>4、是否需要增加worker线程，如果线程池还没有完全终止，仍需要保持一定数量的线程<br>​    线程池状态是running 或 shutdown<br>​    A、如果当前线程是突然终止的，addWorker()<br>​    B、如果当前线程不是突然终止的，但当前线程数量 &lt; 要维护的线程数量，addWorker()<br>​    故如果调用线程池shutdown()，直到workQueue为空前，线程池都会维持corePoolSize个线程，然后再逐渐销毁这corePoolSize个线程</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/24/使用Hexo搭建Github-page/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wanyajing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yestermorrow">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/24/使用Hexo搭建Github-page/" itemprop="url">使用Hexo搭建Github page</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-24T14:35:28+08:00">
                2018-01-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用Hexo搭建Github-page"><a href="#使用Hexo搭建Github-page" class="headerlink" title="使用Hexo搭建Github page"></a>使用Hexo搭建Github page</h1><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>Node.js安装（<a href="https://www.jianshu.com/p/03a76b2e7e00" target="_blank" rel="noopener">链接</a>）<br>Git安装（<a href="http://blog.csdn.net/renfufei/article/details/41647875" target="_blank" rel="noopener">链接</a>）</p>
<h3 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><p>打开git bash.exe, 进入适当的文件夹路径 ，输入</p>
<pre><code>$npm install -g hexo-cli
</code></pre><p> 检查hexo是否安装成功</p>
<pre><code>$ hexo -v
hexo-cli: 1.0.4
os: Windows_NT 10.0.15063 win32 x64
http_parser: 2.7.0
node: 8.9.4
v8: 6.1.534.50
uv: 1.15.0
zlib: 1.2.11
ares: 1.10.1-DEV
modules: 57
nghttp2: 1.25.0
openssl: 1.0.2n
icu: 59.1
unicode: 9.0
cldr: 31.0.1
tz: 2017b
</code></pre><p>初始化hexo</p>
<pre><code>hexo init
npm install
</code></pre><p>安装Hexo关于启动服务器的插件</p>
<pre><code>npm install hexo-server --save
</code></pre><p>启动服务器</p>
<pre><code>hexo server
</code></pre><p>查看效果，网页打开localhost:4000,即可</p>
<h3 id="搭建Git-pages"><a href="#搭建Git-pages" class="headerlink" title="搭建Git pages"></a>搭建Git pages</h3><p>github上新建仓库，命名为yourname.github.io</p>
<p>安装Hexo关于git的组件</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p>在_config.yml 中为 git 添加配置</p>
<pre><code>// 这个一般是在最后,直接往下滑
deploy:
type: git
repository: 你的仓库地址(https://github.com/用户名/用户名.github.io.git)
branch: master
</code></pre><p>执行(每次修改都要执行这些命令才能在github pages看到效果)<br>​<br>    hexo generate<br>    hexo deploy</p>
<h3 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h3><p>新建博客<br>​<br>    //这个地方，当文章名为中文的时候，内容有中文不会出现乱码。但是当文章名是英文的时候，若内容中有中文就会出现乱码，摸索中<br>    hexo new  “文章名”</p>
<p>命令结束后,会在 source/_post下自动生成一个 “文章名.md文件”.(你会看到一个 hello world.md 这个是默认的那个,可以删除)</p>
<p>写好后,生成 部署即可. （需先进入博客目录，如cd d/blog）</p>
<pre><code>hexo generate
hexo deploy
</code></pre><p>删除博客的话,直接将source/_post下对应的 .md文件删除即可 ;重新编译文章,找到这个.md文件打开重新编辑,最后 再次生成部署即可,有时候会存在一定的延迟,这跟网速有关.</p>
<p>命令</p>
<pre><code>hexo g = hexo generate
hexo d = hexo deploy
hexo s = hexo server
</code></pre><h2 id="HEXO主题设置"><a href="#HEXO主题设置" class="headerlink" title="HEXO主题设置"></a>HEXO主题设置</h2><p>默认的hexo主题不喜欢的话可以自定义主题，就以最多使用的next主题为例，介绍一下主题设置流程</p>
<p>进入blog下的themes文件夹，下载next主题</p>
<pre><code>git clone https://github.com/iissnan/hexo-theme-next themes/next
</code></pre><p>这样 D:\blog\themes就会出现next文件夹，下载的主题就在里面了</p>
<h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>首先，需要在阿里云或者其他渠道购买域名，以笔者在阿里云购买的域名(www.wanyajing.top)为例<br><img src="/2018/01/24/使用Hexo搭建Github-page/www.png" alt="Alt text"></p>
<p>注意第一行和第二行记录值设置，CNAME设置为你的github.pages域名，如yestermorrow.github.io，A设置为你的github.pages指向的ip地址（ping一下yestermorrow.github.io就能知道ip啦）。等待五分钟左右，直接输入自己域名就能进入你的github.pages了。</p>
<p> <strong>注意</strong><br> 1：每次修改_config.yml或者md文件时，本机起服务能看见效果，github.io博客看不见效果时</p>
<pre><code>hexo clean
hexo d -g
</code></pre><p>2： 启动hexo服务器显示端口被占用时</p>
<pre><code>hexo s -p 5000
</code></pre><p>3：新建博客时，先hexo new “文章名”，再用马克飞象打开。若直接使用马克飞象新建文件，会出现hexo打开后显示文件名为———-未命名等异常情况。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/23/马克飞象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wanyajing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yestermorrow">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/23/马克飞象/" itemprop="url">马克飞象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-23T13:38:48+08:00">
                2018-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="欢迎使用马克飞象"><a href="#欢迎使用马克飞象" class="headerlink" title="欢迎使用马克飞象"></a>欢迎使用马克飞象</h1><p>@(示例笔记本)[马克飞象|帮助|Markdown]</p>
<p><strong>马克飞象</strong>是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述：</p>
<ul>
<li><strong>功能丰富</strong> ：支持高亮代码块、<em>LaTeX</em> 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；</li>
<li><strong>得心应手</strong> ：简洁高效的编辑器，提供<a href="http://maxiang.info/client_zh" target="_blank" rel="noopener">桌面客户端</a>以及<a href="https://chrome.google.com/webstore/detail/kidnkfckhbdkfgbicccmdggmpgogehop" target="_blank" rel="noopener">离线Chrome App</a>，支持移动端 Web；</li>
<li><strong>深度整合</strong> ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。</li>
</ul>
<hr>
<p>[TOC]</p>
<h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">维基百科</a></p>
</blockquote>
<p>正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.example.com" target="_blank" rel="noopener">链接</a>或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按<code>Ctrl + /</code>查看帮助。 </p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></table></figure>
<h3 id="LaTeX-公式"><a href="#LaTeX-公式" class="headerlink" title="LaTeX 公式"></a>LaTeX 公式</h3><p>可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式：</p>
<p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table>
<thead>
<tr>
<th style="text-align:left">Item</th>
<th style="text-align:right">Value</th>
<th style="text-align:center">Qty</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Computer</td>
<td style="text-align:right">1600 USD</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:left">Phone</td>
<td style="text-align:right">12 USD</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:left">Pipe</td>
<td style="text-align:right">1 USD</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">e=&gt;end</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>
<p>以及时序图:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示：</strong>想了解更多，请查看<strong>流程图</strong><a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">语法</a>以及<strong>时序图</strong><a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">语法</a>。</p>
</blockquote>
<h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>使用 <code>- [ ]</code> 和 <code>- [x]</code> 语法可以创建复选框，实现 todo-list 等功能。例如：</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 已完成事项</li>
<li style="list-style: none"><input type="checkbox"> 待办事项1</li>
<li style="list-style: none"><input type="checkbox"> 待办事项2</li>
</ul>
<blockquote>
<p><strong>注意：</strong>目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在<strong>马克飞象</strong>中修改 Markdown 原文才可生效。下个版本将会全面支持。</p>
</blockquote>
<h2 id="印象笔记相关"><a href="#印象笔记相关" class="headerlink" title="印象笔记相关"></a>印象笔记相关</h2><h3 id="笔记本和标签"><a href="#笔记本和标签" class="headerlink" title="笔记本和标签"></a>笔记本和标签</h3><p><strong>马克飞象</strong>增加了<code>@(笔记本)[标签A|标签B]</code>语法, 以选择笔记本和添加标签。 <strong>绑定账号后</strong>， 输入<code>(</code>自动会出现笔记本列表，请从中选择。</p>
<h3 id="笔记标题"><a href="#笔记标题" class="headerlink" title="笔记标题"></a>笔记标题</h3><p><strong>马克飞象</strong>会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 <code>欢迎使用马克飞象</code>。</p>
<h3 id="快捷编辑"><a href="#快捷编辑" class="headerlink" title="快捷编辑"></a>快捷编辑</h3><p>保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到<strong>马克飞象</strong>中打开并编辑该笔记。</p>
<blockquote>
<p><strong>注意：</strong>目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。</p>
</blockquote>
<h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p><strong>马克飞象</strong>通过<strong>将Markdown原文以隐藏内容保存在笔记中</strong>的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。</p>
<blockquote>
<p><strong>隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。</strong></p>
</blockquote>
<h3 id="离线存储"><a href="#离线存储" class="headerlink" title="离线存储"></a>离线存储</h3><p><strong>马克飞象</strong>使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过<code>文档管理</code>打开。</p>
<blockquote>
<p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，<strong>请务必经常及时同步到印象笔记</strong>。</p>
</blockquote>
<h2 id="编辑器相关"><a href="#编辑器相关" class="headerlink" title="编辑器相关"></a>编辑器相关</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>右侧系统菜单（快捷键<code>Ctrl + M</code>）的<code>设置</code>中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。</p>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>帮助    <code>Ctrl + /</code><br>同步文档    <code>Ctrl + S</code><br>创建文档    <code>Ctrl + Alt + N</code><br>最大化编辑器    <code>Ctrl + Enter</code><br>预览文档 <code>Ctrl + Alt + Enter</code><br>文档管理    <code>Ctrl + O</code><br>系统菜单    <code>Ctrl + M</code> </p>
<p>加粗    <code>Ctrl + B</code><br>插入图片    <code>Ctrl + G</code><br>插入链接    <code>Ctrl + L</code><br>提升标题    <code>Ctrl + H</code></p>
<h2 id="关于收费"><a href="#关于收费" class="headerlink" title="关于收费"></a>关于收费</h2><p><strong>马克飞象</strong>为新用户提供 10 天的试用期，试用期过后需要<a href="maxiang.info/vip.html">续费</a>才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。</p>
<h2 id="反馈与建议"><a href="#反馈与建议" class="headerlink" title="反馈与建议"></a>反馈与建议</h2><ul>
<li>微博：<a href="http://weibo.com/u/2788354117" target="_blank" rel="noopener">@马克飞象</a>，<a href="http://weibo.com/ggock" title="开发者个人账号" target="_blank" rel="noopener">@GGock</a></li>
<li>邮箱：<a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x68;&#x75;&#x73;&#x74;&#x67;&#111;&#x63;&#x6b;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;">&#x68;&#x75;&#x73;&#x74;&#x67;&#111;&#x63;&#x6b;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;</a></li>
</ul>
<hr>
<p>感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。</p>
<p>[^demo]: 这是一个示例脚注。请查阅 <a href="https://github.com/fletcher/MultiMarkdown/wiki/MultiMarkdown-Syntax-Guide#footnotes" target="_blank" rel="noopener">MultiMarkdown 文档</a> 关于脚注的说明。 <strong>限制：</strong> 印象笔记的笔记内容使用 <a href="https://dev.yinxiang.com/doc/articles/enml.php" target="_blank" rel="noopener">ENML</a> 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致<code>脚注</code>和<code>TOC</code>无法正常点击。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/cat.jpg"
                alt="wanyajing" />
            
              <p class="site-author-name" itemprop="name">wanyajing</p>
              <p class="site-description motion-element" itemprop="description">Living Programming Thinking</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yestermorrow" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wanyajing</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
